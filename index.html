<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Floydâ€“Steinberg Dithering</title>
    <style>
        body {
            font-family: system-ui, sans-serif;
            background: #f4f4f4;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2em;
            gap: 1em;
        }

        canvas {
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.1);
            max-width: 90vw;
        }

        canvas.pixelated {
            image-rendering: pixelated;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1em;
            align-items: center;
            justify-content: center;
        }

        button,
        select,
        input {
            padding: 0.5em 1.2em;
            border-radius: 6px;
            font-size: 1em;
        }

        button {
            border: none;
            background: #007bff;
            color: white;
            cursor: pointer;
            font-weight: 600;
        }

        button:disabled {
            background: #aaa;
            cursor: default;
        }

        fieldset {
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 1em;
            background: white;
            width: fit-content;
        }

        legend {
            font-weight: 600;
        }

        .info {
            color: #333;
            font-size: 0.9em;
        }

        .palette-controls {
            display: grid;
            grid-template-columns: repeat(32, 1fr);
            gap: 6px;
            justify-content: center;
            padding: 0.5em;
            box-sizing: border-box;
        }

        @media (max-width: 1130px) {
            .palette-controls {
                grid-template-columns: repeat(16, 1fr);
            }
        }

        @media (max-width: 590px) {
            .palette-controls {
                grid-template-columns: repeat(8, 1fr);
            }
        }

        .color-btn {
            width: 24px;
            height: 24px;
            border: 2px solid #666;
            border-radius: 4px;
            cursor: pointer;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.2);
            transition: transform 0.1s, opacity 0.2s, border-color 0.2s;
        }

        .color-btn.enabled {
            opacity: 1;
            border-color: #222;
        }

        .color-btn.disabled {
            opacity: 0.3;
            border-color: #aaa;
        }

        .canvas-wrapper {
            position: relative;
            width: 100%;
            aspect-ratio: 100 / 60;
            /* height = 60% of width */
            overflow: hidden;
            border: 2px solid #ccc;
            border-radius: 12px;
            background: #222;
            touch-action: none;
            /* disable browser gestures */
            cursor: grab;
        }

        .canvas-wrapper:active {
            cursor: grabbing;
        }

        .canvas-wrapper canvas {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
        }
    </style>
</head>

<body>
    <h1>ðŸŽ¨ Floydâ€“Steinberg Dithering Demo</h1>

    <div class="controls">
        <input type="file" id="fileInput" accept="image/*">
        <label>Scale: <input type="number" id="scaleInput" value="1.00" step="0.05" min="0.05"
                style="width:60px"></label>
        <label>Interpolation:
            <select id="interpolation">
                <option value="nearest">Nearest</option>
                <option value="bilinear" selected>Bilinear</option>
                <option value="bicubic">Bicubic</option>
            </select>
        </label>
        <button id="downloadBtn" disabled>Download Dithered Image</button>
    </div>

    <fieldset>
        <legend>Advanced Dithering Controls</legend>
        <div class="controls">
            <label
                title="Controls how much color error spreads to neighboring pixels. Set to 1.0 for classic Floydâ€“Steinberg diffusion, or lower values for a sharper, more pixelated look.">
                Diffusion Ratio
                <input type="number" id="ratioInput" value="0.75" step="0.05" min="0" max="2">
            </label>

            <label
                title="Adjusts how brightness differences are perceived when finding the nearest palette color. Use 1.0 for linear RGB; higher values (e.g. 1.5â€“2) make bright areas smoother; lower values emphasize dark tones.">
                Gamma
                <input type="number" id="gammaInput" value="1.2" step="0.1" min="0.1" max="3">
            </label>

            <label
                title="Changes how much importance is given to human color sensitivity. Use 0 for pure RGB distance; 1.0 gives more realistic perceptual weighting (green matters more, blue less).">
                Balance
                <input type="number" id="balanceInput" value="0.75" step="0.05" min="0.00" max="2.00">
            </label>

            <label
                title="Controls how much colorful pixels avoid mid-grey palette colors. Higher values make colorful areas less likely to map to grey.">
                Grey Penalty
                <input type="number" id="greyPenaltyInput" value="0.3" step="0.05" min="0" max="2">
            </label>

            <label
                title="Limits error diffusion near edges. Higher = sharper edges, lower = smoother blending. Use this to reduce unwanted specular highlights.">
                Edge Falloff
                <input type="number" id="edgeFalloffInput" value="0.05" step="0.05" min="0" max="5">
            </label>

            <label
                title="Limits how large a color correction error can spread to neighboring pixels. Lower values make diffusion weaker and preserve edges; higher values produce smoother dithering transitions.">
                Error Clip
                <input type="number" id="errorClipInput" value="128" step="1" min="0" max="512">
            </label>

            <label
                title="Adds random noise before quantizing each pixel. Small values (0â€“8) reduce banding; large values create a more film-grain look. Set to 0 for perfectly clean dithering.">
                Jitter
                <input type="number" id="jitterInput" value="8" step="1" min="0" max="64">
            </label>

            <label
                title="Sets the random seed used for Jitter noise. Change this to produce different but repeatable random patterns for the same image.">
                Seed
                <input type="number" id="seedInput" value="42" step="1" min="0">
            </label>
        </div>
    </fieldset>


    <fieldset>
        <legend>Color Palette</legend>
        <div id="paletteControls" class="palette-controls"></div>
    </fieldset>

    <div class="info" id="infoText">No image loaded.</div>
    <input type="range" id="compareSlider" min="0" max="1" step="0.01" value="1">

    <div class="canvas-wrapper" id="canvasWrapper">
        <canvas id="beforeCanvas"></canvas>
        <canvas id="canvas"></canvas>
    </div>


    <script>
        // ---- Floydâ€“Steinberg Dithering Core ----
        function makeDistanceFunction(palette, channelBalance = 0.75, gammaInput = 1.2, chromaWeight = 0.3) {
            const f = x => Math.pow(x / 255, gammaInput);

            // Precompute linearized palette and per-entry metadata
            const paletteMeta = palette.map(([r, g, b]) => {
                const pl = [f(r), f(g), f(b)];
                const pChroma = Math.max(pl[0], pl[1], pl[2]) - Math.min(pl[0], pl[1], pl[2]);
                const pLightness = (pl[0] + pl[1] + pl[2]) / 3;
                const isMidGrey = pChroma < 0.1 && pLightness > 0.15 && pLightness < 0.85;
                return { pl, pChroma, pLightness, isMidGrey };
            });

            const weights = [0.3, 0.59, 0.11].map(w => Math.pow(w, channelBalance));

            // The returned function only needs the source color (0..255)
            return function distanceFn(color) {
                // color is expected as [r,g,b,...]
                const colorLin = [f(color[0]), f(color[1]), f(color[2])];
                const colorChroma = Math.max(colorLin[0], colorLin[1], colorLin[2]) - Math.min(colorLin[0], colorLin[1], colorLin[2]);

                let minDist = Infinity;
                let bestIdx = 0;

                for (let i = 0; i < paletteMeta.length; i++) {
                    const p = paletteMeta[i].pl;

                    const d0 = p[0] - colorLin[0];
                    const d1 = p[1] - colorLin[1];
                    const d2 = p[2] - colorLin[2];

                    const dist = weights[0] * d0 * d0 + weights[1] * d1 * d1 + weights[2] * d2 * d2;

                    const greyPenalty = (paletteMeta[i].isMidGrey && colorChroma > 0.1)
                        ? colorChroma * chromaWeight
                        : 0;

                    const adjusted = dist + greyPenalty;

                    if (adjusted < minDist) {
                        minDist = adjusted;
                        bestIdx = i;
                    }
                }

                return bestIdx;
            };
        }


        // Dithering function uses the prebuilt distance function for speed.
        function floydSteinbergDither(img, palette, ratio = 0.8, errorClip = 255.0,
            jitter = 8, channelBalance = 0.75, gammaInput = 1.2, seed = 42, chromaWeight = 0.3, edgeFalloff = 0.5) {

            const h = img.length, w = img[0].length;
            const output = Array.from({ length: h }, () => Array.from({ length: w }, () => [0, 0, 0, 255]));
            const errorImg = img.map(row => row.map(px => [...px]));
            let rngState = seed >>> 0;
            const rand = () => ((rngState = (1664525 * rngState + 1013904223) >>> 0) / 0x100000000);

            const distanceFn = makeDistanceFunction(palette, channelBalance, gammaInput, chromaWeight);

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const oldPixel = errorImg[y][x];
                    const alpha = (oldPixel[3] ?? 255) / 255;
                    if (alpha <= 0.001) {
                        output[y][x] = [0, 0, 0, 0];
                        continue;
                    }

                    // Add noise for dithering
                    const noise = [
                        (rand() * 2 - 1 + rand() * 2 - 1) * (jitter / 2),
                        (rand() * 2 - 1 + rand() * 2 - 1) * (jitter / 2),
                        (rand() * 2 - 1 + rand() * 2 - 1) * (jitter / 2)
                    ];
                    const noisyPixel = oldPixel.map((v, i) => i < 3
                        ? Math.min(255, Math.max(0, v + noise[i]))
                        : v);

                    const idx = distanceFn(noisyPixel);
                    const newPixel = palette[idx];
                    output[y][x] = [...newPixel, oldPixel[3]];

                    const quantError = oldPixel.slice(0, 3).map((v, i) =>
                        Math.max(-errorClip, Math.min(errorClip, v - newPixel[i]))
                    );

                    // === Compute local gradient magnitude from the original (pre-error) image ===
                    let gradSq = 0;
                    const base = img[y][x];
                    if (x > 0) {
                        const prev = img[y][x - 1];
                        gradSq +=
                            Math.pow(base[0] - prev[0], 2) +
                            Math.pow(base[1] - prev[1], 2) +
                            Math.pow(base[2] - prev[2], 2);
                    }
                    if (y > 0) {
                        const prev = img[y - 1][x];
                        gradSq +=
                            Math.pow(base[0] - prev[0], 2) +
                            Math.pow(base[1] - prev[1], 2) +
                            Math.pow(base[2] - prev[2], 2);
                    }

                    // Normalize gradient (optional)
                    gradSq /= 6 * 255 * 255; // average over channels and neighbors

                    const edgeWeight = Math.exp(-gradSq * edgeFalloff);

                    // Scale the diffusion by both alpha and edge smoothness
                    const aRatio = ratio * alpha * edgeWeight;

                    // Diffuse quantization error
                    if (x + 1 < w)
                        for (let i = 0; i < 3; i++) errorImg[y][x + 1][i] += quantError[i] * (7 / 16) * aRatio;
                    if (y + 1 < h) {
                        if (x > 0)
                            for (let i = 0; i < 3; i++) errorImg[y + 1][x - 1][i] += quantError[i] * (3 / 16) * aRatio;
                        for (let i = 0; i < 3; i++) errorImg[y + 1][x][i] += quantError[i] * (5 / 16) * aRatio;
                        if (x + 1 < w)
                            for (let i = 0; i < 3; i++) errorImg[y + 1][x + 1][i] += quantError[i] * (1 / 16) * aRatio;
                    }
                }
            }

            return output;
        }




        // ---- UI Setup ----
        const fileInput = document.getElementById('fileInput');
        const scaleInput = document.getElementById('scaleInput');
        const interpolation = document.getElementById('interpolation');
        const downloadBtn = document.getElementById('downloadBtn');
        const infoText = document.getElementById('infoText');
        const canvas = document.getElementById('canvas');
        const beforeCanvas = document.getElementById('beforeCanvas');
        const compareSlider = document.getElementById('compareSlider');
        const ctx = canvas.getContext('2d');

        const ratioInput = document.getElementById('ratioInput');
        const jitterInput = document.getElementById('jitterInput');
        const gammaInput = document.getElementById('gammaInput');
        const balanceInput = document.getElementById('balanceInput');
        const seedInput = document.getElementById('seedInput');
        const paletteControls = document.getElementById('paletteControls');
        const greyPenaltyInput = document.getElementById('greyPenaltyInput');
        const edgeFalloffInput = document.getElementById('edgeFalloffInput');
        const errorClipInput = document.getElementById('errorClipInput');

        const PALETTE = [
            [0, 0, 0, "Black"], [60, 60, 60, "Dark Gray"], [120, 120, 120, "Gray"],
            [170, 170, 170, "Medium Gray"], [210, 210, 210, "Light Gray"], [255, 255, 255, "White"],
            [96, 0, 24, "Deep Red"], [165, 14, 30, "Dark Red"], [237, 28, 36, "Red"],
            [250, 128, 114, "Light Red"], [228, 92, 26, "Dark Orange"], [255, 127, 39, "Orange"],
            [246, 170, 9, "Gold"], [249, 221, 59, "Yellow"], [255, 250, 188, "Light Yellow"],
            [156, 132, 49, "Dark Goldenrod"], [197, 173, 49, "Goldenrod"], [232, 212, 95, "Light Goldenrod"],
            [74, 107, 58, "Dark Olive"], [90, 148, 74, "Olive"], [132, 197, 115, "Light Olive"],
            [14, 185, 104, "Dark Green"], [19, 230, 123, "Green"], [135, 255, 94, "Light Green"],
            [12, 129, 110, "Dark Teal"], [16, 174, 166, "Teal"], [19, 225, 190, "Light Teal"],
            [15, 121, 159, "Dark Cyan"], [96, 247, 242, "Cyan"], [187, 250, 242, "Light Cyan"],
            [40, 80, 158, "Dark Blue"], [64, 147, 228, "Blue"], [125, 199, 255, "Light Blue"],
            [77, 49, 184, "Dark Indigo"], [107, 80, 246, "Indigo"], [153, 177, 251, "Light Indigo"],
            [74, 66, 132, "Dark Slate Blue"], [122, 113, 196, "Slate Blue"], [181, 174, 241, "Light Slate Blue"],
            [120, 12, 153, "Dark Purple"], [170, 56, 185, "Purple"], [224, 159, 249, "Light Purple"],
            [203, 0, 122, "Dark Pink"], [236, 31, 128, "Pink"], [243, 141, 169, "Light Pink"],
            [155, 82, 73, "Dark Peach"], [209, 128, 120, "Peach"], [250, 182, 164, "Light Peach"],
            [104, 70, 52, "Dark Brown"], [149, 104, 42, "Brown"], [219, 164, 99, "Light Brown"],
            [123, 99, 82, "Dark Tan"], [156, 132, 107, "Tan"], [214, 181, 148, "Light Tan"],
            [209, 128, 81, "Dark Beige"], [248, 178, 119, "Beige"], [255, 197, 165, "Light Beige"],
            [109, 100, 63, "Dark Stone"], [148, 140, 107, "Stone"], [205, 197, 158, "Light Stone"],
            [51, 57, 65, "Dark Slate"], [109, 117, 141, "Slate"], [179, 185, 209, "Light Slate"]
        ];

        let enabledColors = new Array(PALETTE.length).fill(true);
        let lastImage = null;

        // Generate palette buttons
        PALETTE.forEach(([r, g, b, name], i) => {
            const btn = document.createElement('div');
            btn.className = 'color-btn enabled';
            btn.title = name;
            btn.style.backgroundColor = `rgb(${r},${g},${b})`;
            btn.dataset.index = i;
            btn.addEventListener('click', () => {
                enabledColors[i] = !enabledColors[i];
                btn.className = 'color-btn ' + (enabledColors[i] ? 'enabled' : 'disabled');
                if (lastImage) processImage();
            });
            paletteControls.appendChild(btn);
        });

        fileInput.addEventListener('change', e => {
            const file = e.target.files[0];
            if (!file) return;
            const img = new Image();
            img.onload = () => {
                lastImage = img;
                processImage();
                resetTransform();
            };
            img.src = URL.createObjectURL(file);
        });

        let processTimeout;
        function queueProcess() {
            if (processTimeout) clearTimeout(processTimeout);
            processTimeout = setTimeout(() => {
                if (lastImage) processImage();
            }, 100);
        }

        [interpolation, ratioInput, jitterInput, gammaInput, balanceInput, seedInput, greyPenaltyInput, edgeFalloffInput, errorClipInput]
            .forEach(el => el.addEventListener('input', queueProcess));

        [scaleInput].forEach(el => el.addEventListener('input', () => {
            processImage();
            resetTransform();
        }));

        function processImage() {
            const scale = Math.max(parseFloat(scaleInput.value) || 1, 0.1);
            const interp = interpolation.value;
            const ratio = parseFloat(ratioInput.value);
            const jitter = parseFloat(jitterInput.value);
            const gamma = parseFloat(gammaInput.value);
            const balance = parseFloat(balanceInput.value);
            const seed = parseInt(seedInput.value);
            const greyPenalty = parseFloat(greyPenaltyInput.value);
            const edgeFalloff = parseFloat(edgeFalloffInput.value);
            const errorClip = parseFloat(errorClipInput.value);

            const activePalette = PALETTE.filter((_, i) => enabledColors[i]).map(([r, g, b]) => [r, g, b]);

            const w = Math.round(lastImage.width * scale);
            const h = Math.round(lastImage.height * scale);

            canvas.width = w;
            canvas.height = h;
            ctx.imageSmoothingEnabled = interp !== 'nearest';
            ctx.imageSmoothingQuality = interp === 'bicubic' ? 'high' : interp === 'bilinear' ? 'medium' : 'low';

            beforeCanvas.width = w;
            beforeCanvas.height = h;
            beforeCanvas.getContext('2d').drawImage(lastImage, 0, 0, w, h);

            ctx.clearRect(0, 0, w, h);
            ctx.drawImage(lastImage, 0, 0, w, h);

            const imgData = ctx.getImageData(0, 0, w, h);
            const data = imgData.data;

            const pixels = [];
            for (let y = 0; y < h; y++) {
                const row = [];
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    row.push([data[i], data[i + 1], data[i + 2], data[i + 3]]);
                }
                pixels.push(row);
            }

            const dithered = floydSteinbergDither(pixels, activePalette, ratio, errorClip, jitter, balance, gamma, seed, greyPenalty, edgeFalloff);

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const [r, g, b] = dithered[y][x];
                    const i = (y * w + x) * 4;
                    data[i] = r;
                    data[i + 1] = g;
                    data[i + 2] = b;
                    data[i + 3] = data[i + 3] < 96 ? 0 : 255;
                }
            }

            ctx.putImageData(imgData, 0, 0);
            downloadBtn.disabled = false;
            infoText.textContent =
                `Original: ${lastImage.width}Ã—${lastImage.height} â†’ Dithered: ${w}Ã—${h} (${interp}), ` +
                `ratio=${ratio}, jitter=${jitter}, gamma=${gamma}, balance=${balance}, seed=${seed}, active colors=${activePalette.length}`;

            // ---- Sync compare slider (split view: original left, dithered right) ----
            function updateCompareClip() {
                const value = compareSlider.value * 100;
                // Show left part of original, right part of dithered
                beforeCanvas.style.clipPath = `inset(0 0 0 ${value}%)`;
                canvas.style.clipPath = `inset(0 ${100 - value}% 0 0)`;
            }

            updateCompareClip(); // initialize
            compareSlider.addEventListener('input', updateCompareClip);
        }

        downloadBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'dithered.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        });
    </script>
    <script>
        // ---- Pan & Zoom Controls (Pixel-anchored zoom + centered start) ----
        const wrapper = document.getElementById('canvasWrapper');

        let zoom = 1;
        let offsetX = 0, offsetY = 0;
        let isDragging = false;
        let lastX = 0, lastY = 0;

        function updateCanvasTransform() {
            canvas.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${zoom})`;
            beforeCanvas.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${zoom})`;

            // Apply pixelated rendering only if zoomed in
            if (zoom > 1.01) {
                canvas.classList.add('pixelated');
                beforeCanvas.classList.add('pixelated');
            } else {
                canvas.classList.remove('pixelated');
                beforeCanvas.classList.remove('pixelated');
            }
        }


        // Center canvas in wrapper
        function centerCanvas() {
            const rect = wrapper.getBoundingClientRect();
            const w = canvas.width * zoom;
            const h = canvas.height * zoom;
            offsetX = (rect.width - w) / 2;
            offsetY = (rect.height - h) / 2;
            updateCanvasTransform();
        }

        // Wheel zoom (keep pixel at cursor fixed)
        wrapper.addEventListener('wheel', e => {
            e.preventDefault();

            const rect = wrapper.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Convert screen coordinates to "world" coordinates
            const worldX = (mouseX - offsetX) / zoom;
            const worldY = (mouseY - offsetY) / zoom;

            // Apply zoom delta
            const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
            const newZoom = Math.min(Math.max(zoom * zoomFactor, 0.2), 10);

            // Adjust pan to keep world point fixed
            offsetX = mouseX - worldX * newZoom;
            offsetY = mouseY - worldY * newZoom;
            zoom = newZoom;

            updateCanvasTransform();
        });

        // Drag panning
        wrapper.addEventListener('mousedown', e => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
            wrapper.style.cursor = 'grabbing';
        });
        window.addEventListener('mouseup', () => {
            isDragging = false;
            wrapper.style.cursor = 'grab';
        });
        window.addEventListener('mousemove', e => {
            if (!isDragging) return;
            offsetX += e.clientX - lastX;
            offsetY += e.clientY - lastY;
            lastX = e.clientX;
            lastY = e.clientY;
            updateCanvasTransform();
        });

        // Reset & center after each new image render
        function resetTransform() {
            zoom = 1;
            offsetX = 0;
            offsetY = 0;
            centerCanvas();
        }

        resetTransform();
    </script>
</body>

</html>