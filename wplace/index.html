<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Floydâ€“Steinberg Dithering</title>
    <link rel="stylesheet" href="css/style.css">
</head>

<body>
    <div class="app-container" data-current-tool>
        <aside class="sidebar">
            <h1>ðŸŽ¨ Dithering</h1>

            <section class="settings-section">
                <h2>Image</h2>
                <input type="file" id="fileInput" accept="image/*">
                <input type="url" id="urlInput" placeholder="Image URL...">
                <button id="loadUrlBtn">Load</button>

                <label>Scale:
                    <input type="number" id="scaleInput" value="1.00" step="0.05" min="0.05">
                </label>
                <label>Interpolation:
                    <select id="interpolation">
                        <option value="nearest">Nearest</option>
                        <option value="bilinear" selected>Bilinear</option>
                        <option value="bicubic">Bicubic</option>
                    </select>
                </label>
                <label>
                    Transparency Threshold
                    <input type="number" id="transparencyInput" value="128" step="1" min="0" max="255">
                </label>
            </section>

            <section class="settings-section">
                <h2>Tools</h2>
                <div class="tools-panel">
                    <button id="toolPanBtn" class="tool-btn active">Pan</button>
                    <button id="toolBrushBtn" class="tool-btn">Freeze Mask Edit Brush</button>
                </div>
            </section>

            <section class="settings-section" data-tool="maskEdit">
                <h2
                    title="Used for touch-ups. Click Edit Mask to 'paint' regions you want fixed. Subsequent edits will leave those pixels untouched. Click the button again to leave mask edit mode. Panning and zooming are disabled in this mode. (WIP)">
                    Freeze Mask</h2>

                <label>
                    Brush Size
                    <input type="number" id="brushSize" value="6" step="1" min="0" max="50">
                </label>

                <button id="toggleMaskModeBtn"
                    title="Add mode to set frozen pixels. Subtract mode to unfreeze pixels.">Mode: Add</button>

                <button id="clearMaskBtn" title="Unfreeze all pixels">Clear Mask</button>
                <button id="fillMaskBtn" title="Freeze all pixels">Fill Mask</button>
            </section>

            <section class="settings-section">
                <h2>Dither Settings</h2>

                <fieldset>
                    <legend>Dithering Controls</legend>
                    <div class="advancedControls">
                        <label
                            title="Controls how much color error spreads to neighboring pixels. Set to 1.0 for classic Floydâ€“Steinberg diffusion, or lower values for a sharper, more pixelated look.">
                            Diffusion Ratio
                            <input type="number" id="ratioInput" value="0.75" step="0.05" min="0" max="2">
                        </label>

                        <label
                            title="Adjusts how brightness differences are perceived when finding the nearest palette color. Use 1.0 for linear RGB; higher values (e.g. 1.5â€“2) make bright areas smoother; lower values emphasize dark tones.">
                            Gamma
                            <input type="number" id="gammaInput" value="1.2" step="0.1" min="0.1" max="3">
                        </label>

                        <label
                            title="Controls how much colorful pixels avoid mid-grey palette colors. Higher values make colorful areas less likely to map to grey.">
                            Grey Penalty
                            <input type="number" id="greyPenaltyInput" value="0.3" step="0.05" min="0" max="2">
                        </label>

                        <label
                            title="Limits error diffusion near edges. Higher = sharper edges, lower = smoother blending. Use this to reduce unwanted specular highlights.">
                            Edge Falloff
                            <input type="number" id="edgeFalloffInput" value="0.05" step="0.05" min="0" max="5">
                        </label>

                        <label
                            title="Limits how large a color correction error can spread to neighboring pixels. Lower values make diffusion weaker and preserve edges; higher values produce smoother dithering transitions.">
                            Error Clip
                            <input type="number" id="errorClipInput" value="128" step="1" min="0" max="512">
                        </label>
                    </div>
                </fieldset>

                <fieldset>
                    <legend>Channel Weights</legend>
                    <div class="rgb-balance-box">
                        <label title="Weight multiplied to the red channel for the distance calculation">
                            R Weight
                            <input type="number" id="balanceR" value="0.3" step="0.01" min="0" max="5">
                        </label>
                        <label title="Weight multiplied to the green channel for the distance calculation">
                            G Weight
                            <input type="number" id="balanceG" value="0.59" step="0.01" min="0" max="5">
                        </label>
                        <label title="Weight multiplied to the blue channel for the distance calculation">
                            B Weight
                            <input type="number" id="balanceB" value="0.11" step="0.01" min="0" max="5">
                        </label>
                        <button id="setPerceptualBtn" title="Use perceptual weights">Set Perceptual</button>
                    </div>
                </fieldset>

                <fieldset>
                    <legend>Jitter</legend>
                    <div class="rgb-balance-box">
                        <label
                            title="Adds random noise before quantizing each pixel. Small values (0â€“8) reduce banding; large values create a more film-grain look. Set to 0 for perfectly clean dithering.">
                            Amount
                            <input type="number" id="jitterInput" value="8" step="1" min="0" max="64">
                        </label>

                        <label
                            title="Sets the random seed used for Jitter noise. Change this to produce different but repeatable random patterns for the same image.">
                            Seed
                            <input type="number" id="seedInput" value="42" step="1" min="0">
                        </label>
                    </div>
                </fieldset>
            </section>

            <section class="settings-section">
                <button id="downloadBtn" disabled>Download</button>
                <button id="shareBtn">Share</button>
            </section>
        </aside>

        <main class="main-area">
            <div class="info" id="infoText">No image loaded.</div>
            <input type="range" id="compareSlider" min="0" max="1" step="0.01" value="1">
            <div class="canvas-wrapper" id="canvasWrapper">
                <canvas id="beforeCanvas"></canvas>
                <canvas id="canvas"></canvas>
                <canvas id="maskCanvas"></canvas>
                <canvas id="brushPreviewCanvas"></canvas>
            </div>
        </main>

        <footer class="palette-footer">
            <legend>Color Palette</legend>
            <div id="paletteControls" class="palette-controls"></div>
        </footer>
    </div>

    <script src="js/query.js"></script>
    <script src="js/palette.js"></script>
    <script src="js/dithering.js"></script>
    <script src="js/tools.js"></script>
    <script>
        (function () {
            // ---- UI Setup ----
            const fileInput = document.getElementById('fileInput');
            const scaleInput = document.getElementById('scaleInput');
            const interpolation = document.getElementById('interpolation');
            const downloadBtn = document.getElementById('downloadBtn');
            const infoText = document.getElementById('infoText');
            const canvas = document.getElementById('canvas');
            const beforeCanvas = document.getElementById('beforeCanvas');
            const compareSlider = document.getElementById('compareSlider');
            const maskCanvas = document.getElementById('maskCanvas');
            const brushPreviewCanvas = document.getElementById('brushPreviewCanvas');

            const ctx = canvas.getContext('2d');
            const maskCtx = maskCanvas.getContext('2d');
            const brushPreviewCtx = brushPreviewCanvas.getContext('2d');

            brushPreviewCanvas.style.pointerEvents = 'none';
            brushPreviewCanvas.style.opacity = '0';

            const ratioInput = document.getElementById('ratioInput');
            const jitterInput = document.getElementById('jitterInput');
            const gammaInput = document.getElementById('gammaInput');
            const seedInput = document.getElementById('seedInput');
            const paletteControls = document.getElementById('paletteControls');
            const greyPenaltyInput = document.getElementById('greyPenaltyInput');
            const edgeFalloffInput = document.getElementById('edgeFalloffInput');
            const errorClipInput = document.getElementById('errorClipInput');
            const transparencyInput = document.getElementById('transparencyInput');

            const balanceR = document.getElementById('balanceR');
            const balanceG = document.getElementById('balanceG');
            const balanceB = document.getElementById('balanceB');
            const setPerceptualBtn = document.getElementById('setPerceptualBtn');

            setPerceptualBtn.addEventListener('click', () => {
                balanceR.value = 0.3;
                balanceG.value = 0.59;
                balanceB.value = 0.11;
                if (typeof queueProcess === "function") queueProcess();
            });

            const PALETTE = [
                [0, 0, 0, "Black", false],
                [60, 60, 60, "Dark Gray", false],
                [120, 120, 120, "Gray", false],
                [170, 170, 170, "Medium Gray", true],
                [210, 210, 210, "Light Gray", false],
                [255, 255, 255, "White", false],
                [96, 0, 24, "Deep Red", false],
                [165, 14, 30, "Dark Red", true],
                [237, 28, 36, "Red", false],
                [250, 128, 114, "Light Red", true],
                [228, 92, 26, "Dark Orange", true],
                [255, 127, 39, "Orange", false],
                [246, 170, 9, "Gold", false],
                [249, 221, 59, "Yellow", false],
                [255, 250, 188, "Light Yellow", false],
                [156, 132, 49, "Dark Goldenrod", true],
                [197, 173, 49, "Goldenrod", true],
                [232, 212, 95, "Light Goldenrod", true],
                [74, 107, 58, "Dark Olive", true],
                [90, 148, 74, "Olive", true],
                [132, 197, 115, "Light Olive", true],
                [14, 185, 104, "Dark Green", false],
                [19, 230, 123, "Green", false],
                [135, 255, 94, "Light Green", false],
                [12, 129, 110, "Dark Teal", false],
                [16, 174, 166, "Teal", false],
                [19, 225, 190, "Light Teal", false],
                [15, 121, 159, "Dark Cyan", true],
                [96, 247, 242, "Cyan", false],
                [187, 250, 242, "Light Cyan", true],
                [40, 80, 158, "Dark Blue", false],
                [64, 147, 228, "Blue", false],
                [125, 199, 255, "Light Blue", true],
                [77, 49, 184, "Dark Indigo", true],
                [107, 80, 246, "Indigo", false],
                [153, 177, 251, "Light Indigo", false],
                [74, 66, 132, "Dark Slate Blue", true],
                [122, 113, 196, "Slate Blue", true],
                [181, 174, 241, "Light Slate Blue", true],
                [120, 12, 153, "Dark Purple", false],
                [170, 56, 185, "Purple", false],
                [224, 159, 249, "Light Purple", false],
                [203, 0, 122, "Dark Pink", false],
                [236, 31, 128, "Pink", false],
                [243, 141, 169, "Light Pink", false],
                [155, 82, 73, "Dark Peach", true],
                [209, 128, 120, "Peach", true],
                [250, 182, 164, "Light Peach", true],
                [104, 70, 52, "Dark Brown", false],
                [149, 104, 42, "Brown", false],
                [219, 164, 99, "Light Brown", true],
                [123, 99, 82, "Dark Tan", true],
                [156, 132, 107, "Tan", true],
                [214, 181, 148, "Light Tan", true],
                [209, 128, 81, "Dark Beige", true],
                [248, 178, 119, "Beige", false],
                [255, 197, 165, "Light Beige", true],
                [109, 100, 63, "Dark Stone", true],
                [148, 140, 107, "Stone", true],
                [205, 197, 158, "Light Stone", true],
                [51, 57, 65, "Dark Slate", true],
                [109, 117, 141, "Slate", true],
                [179, 185, 209, "Light Slate", true]
            ];

            let enabledColors = new Array(PALETTE.length).fill(true);
            // Apply query-based palette control
            if (enabledIndices !== null) {
                enabledColors = enabledColors.map((_, i) => enabledIndices.includes(i));
            } else if (disabledIndices.length > 0) {
                disabledIndices.forEach(i => {
                    if (i >= 0 && i < enabledColors.length) enabledColors[i] = false;
                });
            }

            let lastImage = null;
            let lastDithered = null;

            // Generate palette buttons
            PALETTE.forEach(([r, g, b, name, isPaid], i) => {
                const btn = document.createElement('div');
                btn.className = 'color-btn enabled';
                btn.title = name;
                btn.style.backgroundColor = `rgb(${r},${g},${b})`;
                btn.dataset.index = i;

                // --- Add paid indicator ---
                if (isPaid) {
                    const badge = document.createElement('div');
                    badge.className = 'paid-indicator';
                    btn.appendChild(badge);
                }
                // --------------------------

                btn.addEventListener('click', () => {
                    enabledColors[i] = !enabledColors[i];
                    btn.className = 'color-btn ' + (enabledColors[i] ? 'enabled' : 'disabled');
                    if (lastImage) processImage();
                });

                paletteControls.appendChild(btn);
            });


            fileInput.addEventListener('change', e => {
                const file = e.target.files[0];
                if (!file) return;
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.onload = () => {
                    lastImage = img;
                    resizeCanvasesToScale();
                    processImage();
                };
                img.src = URL.createObjectURL(file);
            });

            // ---- Auto-load image if src query parameter provided ----
            if (window.initialImageSrc) {
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.onload = () => {
                    lastImage = img;
                    processImage();
                    resetTransform();
                };
                img.src = window.initialImageSrc;
            }

            let processTimeout;
            function queueProcess() {
                if (processTimeout) clearTimeout(processTimeout);
                processTimeout = setTimeout(() => {
                    if (lastImage) processImage();
                }, 100);
            }

            [interpolation, ratioInput, jitterInput, gammaInput, balanceR, balanceG, balanceB, seedInput, greyPenaltyInput, edgeFalloffInput, errorClipInput, transparencyInput]
                .forEach(el => el.addEventListener('input', queueProcess));

            scaleInput.addEventListener('input', () => {
                resizeCanvasesToScale();
                processImage();
            });

            function resizeCanvasesToScale() {
                if (!lastImage) return;

                const scale = Math.max(parseFloat(scaleInput.value) || 1, 0.1);
                const w = Math.round(lastImage.width * scale);
                const h = Math.round(lastImage.height * scale);

                // Resize only image display canvases â€” leave mask unless necessary
                canvas.width = w;
                canvas.height = h;
                beforeCanvas.width = w;
                beforeCanvas.height = h;
                maskCanvas.width = w;
                maskCanvas.height = h;
                brushPreviewCanvas.width = w;
                brushPreviewCanvas.height = h;

                // Ensure mask exists and matches new size
                const maskNeedsResize = !freezeMask || freezeMask.length !== w * h;
                if (maskNeedsResize) {
                    console.log("resizing freeze mask");
                    freezeMask = new Uint8Array(w * h);
                    maskCanvas.width = w;
                    maskCanvas.height = h;
                    maskCtx.clearRect(0, 0, w, h);
                }

                // Keep other visuals aligned
                resetTransform();
            }

            function processImage() {
                const scale = Math.max(parseFloat(scaleInput.value) || 1, 0.1);
                const interp = interpolation.value;
                const ratio = parseFloat(ratioInput.value);
                const jitter = parseFloat(jitterInput.value);
                const gamma = parseFloat(gammaInput.value);
                const rWeight = parseFloat(balanceR.value);
                const gWeight = parseFloat(balanceG.value);
                const bWeight = parseFloat(balanceB.value);
                const seed = parseInt(seedInput.value);
                const greyPenalty = parseFloat(greyPenaltyInput.value);
                const edgeFalloff = parseFloat(edgeFalloffInput.value);
                const errorClip = parseFloat(errorClipInput.value);
                const transparencyThreshold = parseInt(transparencyInput.value);

                const activePalette = PALETTE.filter((_, i) => enabledColors[i]);

                const w = canvas.width;
                const h = canvas.height;

                ctx.imageSmoothingEnabled = interp !== 'nearest';
                ctx.imageSmoothingQuality = interp === 'bicubic' ? 'high' : interp === 'bilinear' ? 'medium' : 'low';
                beforeCanvas.getContext('2d').drawImage(lastImage, 0, 0, w, h);

                ctx.clearRect(0, 0, w, h);
                ctx.drawImage(lastImage, 0, 0, w, h);

                const imgData = ctx.getImageData(0, 0, w, h);

                const ditheredData = floydSteinbergDither(
                    imgData.data, w, h, lastDithered, activePalette, freezeMask,
                    {
                        ratio, errorClip, jitter, rWeight, gWeight, bWeight,
                        gammaInput: gamma, seed, chromaWeight: greyPenalty, edgeFalloff
                    }
                );

                for (let i = 0; i < ditheredData.length; i += 4) {
                    const pixelIndex = i >> 2;

                    // use previous alpha if frozen
                    if (freezeMask && freezeMask[pixelIndex] && lastDithered) {
                        ditheredData[i + 3] = lastDithered[i + 3]
                    } else {
                        const a = ditheredData[i + 3];
                        ditheredData[i + 3] = (a < transparencyThreshold ? 0 : 255);
                    }

                }

                lastDithered = ditheredData;
                imgData.data.set(ditheredData);
                ctx.putImageData(imgData, 0, 0);

                downloadBtn.disabled = false;
                infoText.textContent =
                    `Original: ${lastImage.width}Ã—${lastImage.height} â†’ Dithered: ${w}Ã—${h} (${interp}), ` +
                    `ratio=${ratio}, jitter=${jitter}, gamma=${gamma}, balance=${balance}, seed=${seed}, active colors=${activePalette.length}`;

            }

            function updateCompareClip() {
                const value = compareSlider.value * 100;
                beforeCanvas.style.clipPath = `inset(0 0 0 ${value}%)`;
                canvas.style.clipPath = `inset(0 ${100 - value}% 0 0)`;
            }

            updateCompareClip();
            compareSlider.addEventListener('input', updateCompareClip);

            downloadBtn.addEventListener('click', () => {
                const link = document.createElement('a');
                link.download = 'dithered.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            });
        })();
    </script>
    <script src="js/share.js"></script>
</body>

</html>